# freeBSD-lab5
## Завдання
Побудуйте програму, яка виділяє пам’ять за допомогою mmap() і втрачає її після fork() — без ознак у valgrind.
## Реалізація завдання
Було написано програму, яка демонструє базову роботу з розподіленням пам’яті за допомогою mmap, а також взаємодію між батьківським і дочірнім процесами через розподілену пам’ять. Розгялнемо кожну функцію окремо.
### Функція виділення пам'яті
```
void* allocate_memory(size_t size) {
    void* mem = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
    if (mem == MAP_FAILED) {
        perror("mmap failed");
        exit(EXIT_FAILURE);
    }
    return mem;
}
```
Ця функція використовує mmap() для виділення анонімної області пам’яті розміром `size` байт. Права доступу — читання та запис. Якщо mmap не вдалося — виводить помилку і завершує програму, інакше — повертає вказівник на початок виділеної пам’яті.
### Функція запису повідомлення
```
void write_message(void* mem) {
    sprintf((char*)mem, "Temporary message\n");
}
```
Дана функція записує у передану область пам’яті текст `Temporary message` за допомогою `sprintf`.
### Функція виконання дочірнього процесу
```
void run_child() {
    _exit(0);
}
```
Ця функція завершує дочірній процес через `_exit(0)` та не виконує жодного очищення або дій над пам’яттю.
**Примітка:** `_exit` використовується, щоб уникнути виклику деструкторів і буферизації, що важливо після `fork()`.
### Функція виконання батківського процесу
```
void run_parent() {
    wait(NULL);
    exit(0);
}
```
Вона очікує завершення дочірнього процесу (реалізовано за допомогою `wait(NULL)`) та завершує програму через `exit(0)`, також не звільнивши виділену пам’ять.
### Головна функція `main()`
Виділяється 1 сторінка пам’яті (PAGE_SIZE = 4096) та записується в цю пам’ять демонстраційне повідомлення. Далі створюється новий процес через fork(). У разі помилки — пам’ять очищується і програма завершує виконання. Якщо `pid == 0` — виконується дочірній процес, інакше — виконується батьківський процес.
## Компіляція та виконання програми
![image](https://github.com/user-attachments/assets/2da4232c-1403-4724-a27b-8494e3265e6c)
## Висновок
Отже, `valgrind` не показав витоків пам’яті, тому що пам’ять була виділена `mmap()`, а не `malloc()`, `_exit()` не викликає обробку дескрипторів і деструкторів. Також за замовчуванням `valgrind` не перевіряє пам’ять, втраченою дочірнім процесом, якщо той правильно завершений.

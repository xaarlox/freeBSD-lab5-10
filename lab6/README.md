# freeBSD-lab6
## Завдання
Зберіть ASan summary table: тип помилки, приклад, реакція інструмента, час виконання.
## Реалізація завдання
Отже, я використовувала [`scan-build`](https://clang.llvm.org/docs/analyzer/user-docs/CommandLineUsage.html#scan-build), адже це інструмент статичного аналізу коду, який виявляє можливі помилки ще під час компіляції, тобто без виконання програми. На відміну від `ASan` чи `Valgrind`, які запускають код, `scan-build` нічого не виконує — просто аналізує шляхами виконання програми.
Було написано програму, яка демонструє три типові помилки пам’яті, які часто трапляються в програмах на мові C. Розглянемо кожну функцію окремо.
### Heap buffer overflow
```
void buffer_overflow() {
    char *buf = malloc(10);
    buf[10] = 'x'; //heap-buffer-overflow
    free(buf);
}
```
У цій функції виділяється 10 байтів пам’яті, але запис здійснюється в 11-й байт. Це призводить до виходу за межі виділеної області пам’яті.
### Use after free
```
void use_after_free() {
    char *buf = malloc(10);
    free(buf);
    buf[0] = 'y'; //heap-use-after-free
}
```
Тут, після виклику free(buf) пам’ять звільнено, але далі здійснюється запис у цю область. Це використання пам’яті після вивільнення.
### Memory leak
```
void heap_leak() {
    char *buf = malloc(100); //memory leak
    strcpy(buf, "memory leak");
    //free(buf);
}
```
Було виділено 100 байтів, але free(buf) закоментовано, тому виникає витік пам’яті — пам’ять не повертається ОС.
## Компіляція та виконання програми
![Знімок екрана 2025-04-22 223926](https://github.com/user-attachments/assets/b432c780-1cf1-47d4-b3fe-593302b4bc62)

![Знімок екрана 2025-04-22 224116](https://github.com/user-attachments/assets/07ab6b64-ad30-4c78-a4f5-ff835d0cdda0)

**Примітка:** за допомогою команди `scan-view` можна подивитися детальний звіт помилок у коді.

# freeBSD_lab8
## Завдання №1
Чи може виклик `count = write(fd, buffer, nbytes);` повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
## Реалізація завдання
Було написано програму, у якій використовується пара каналів `pipe` для демонстрації. Канал створює буфер між процесами для обміну даними. *Що відбувається*:
1. Функція `pipe()` створює два файлові дескриптори `pipefd[0]` (читання) і `pipefd[1]` (запис).
2. Використовується `fcntl`, щоб встановити неблокуючий режим для `pipefd[1]` (кінця запису).
3. Далі створюється буфер `buffer` розміром 64 KB, заповнений символом 'A'.
4. Запис у `pipefd[1]` здійснюється за допомогою `write`.
5. Якщо даних у буфер не вистачає або виникає інша проблема, код виводить відповідне повідомлення.
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 163131](https://github.com/user-attachments/assets/0bcd0908-b5ed-4dbc-b4ad-8f9d154ce24c)

## Завдання №2
Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
+ lseek(fd, 3, SEEK_SET);
+ read(fd, &buffer, 4);

де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
## Реалізація завдання
Було еаписано програму, яка демонструє системні виклики `lseek` та `read` для доступу до файлу. Спочатку створюється файл `test.bin` та заповнюється масивом байтів: {4, 5, 2, 2, 3, 3, 7, 9, 1, 5}. Це робиться викликами `open` (з прапорцями `O_CREAT | O_WRONLY | O_TRUNC`) та `write`. Після створення, файл відкривається у режимі лише для читання (`O_RDONLY`). Системний виклик `lseek(fd, 3, SEEK_SET)` встановлює покажчик читання на третій байт файлу. Тобто покажчик буде вказувати на байт із значенням 2. Виклик `read(fd, &buffer, 4)` читає 4 байти, починаючи з поточного положення покажчика. Ці байти: {2, 3, 3, 7}. Після чого програма виводить кількість зчитаних байтів та їх вміст на екран.
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 164242](https://github.com/user-attachments/assets/fbba4f92-6262-4ed3-9734-247dae18f816)

## Завдання №3
Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення. Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
- Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
- Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

## Реалізація завдання
Було написано програму, яка генерує масиви з різними структурами даних: відсортований, перевернутий, випадковий, однакові елементи та порівнює продуктивність сортування на цих структурах.
**Функція порівняння (`compare_ints`)**. Ця функція реалізує порівняння двох цілих чисел:
* Вона використовує вказівники `void*`, приводячи їх до типу `int*`.
* Повертає значення: -1, 0, або 1, залежно від того, менше, рівне чи більше перше значення щодо другого.

**Генерація даних**. Код включає функції для заповнення масиву різними типами даних:
+ `fill_sorted`: Генерує вже відсортований масив (найкращий випадок для `qsort`).
+ `fill_reversed`: Генерує масив у зворотному порядку (найгірший випадок для більшості сортувань).
+ `fill_random`: Заповнює масив випадковими числами.
+ `fill_equal`: Усі елементи масиву однакові.

**Тестування продуктивності: `benchmark`**.
- Генерує масив з використанням одного з методів заповнення.
- Заміряє час виконання `qsort`, використовуючи `clock`.
- Перевіряє, чи масив правильно відсортований, за допомогою функції `is_sorted`.

**Тест правильності: `is_sorted`**. Функція проходить по масиву та перевіряє, чи всі елементи у правильному порядку.
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 165952](https://github.com/user-attachments/assets/91f6f21e-5dce-4f07-a78b-785fb72f00b6)

## Завдання №4
Виконайте наступну програму на мові програмування С:
```
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
```
Завершіть цю програму. Припускаючи, що виклик `fork()` був успішним, яким може бути результат виконання цієї програми?
## Реалізація завдання
Припускаючи, що `fork()` успішний:
* У батьківському процесі буде надрукований PID дочірнього процесу (наприклад, 1148).
* У дочірньому процесі буде надруковано 0.

Програма виводить два числа, але порядок їх появи на екрані може бути довільним (залежить від того, який процес виконає printf першим).
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 170259](https://github.com/user-attachments/assets/fa046eab-1236-40ee-8b5e-8eb3671c48d1)

## Завдання №20
Напишіть програму, яка демонструє неочевидну поведінку при відкритті одного файлу кілька разів з різними прапорами.
## Реалізація завдання
Було написано програму, яка демонструє неочевидну поведінку при відкритті одного файлу кілька разів для читання з різними файловими дескрипторами. Розглянемо кожен етап окремо:
1. **Ініціалізація файлу**. Файл `test_shared.txt` створюється із прапорами `O_WRONLY | O_CREAT | O_TRUNC`, що означає, що файл відкривається для запису, створюється (якщо не існує) і очищується. У файл записується рядок `ABCDEFGHIJ`, довжиною 10 байт.
2. **Відкриття одного файлу двічі**. Файл відкривається двічі для читання, кожен раз отримуючи окремий дескриптор `fd1` та `fd2`. Курсори для читання кожного дескриптора починають із початкової позиції.
3. **Читання за допомогою дескрипторів**. Використання функції `read(fd1, buf, 1)` читає перший байт (символ 'A') із дескриптора `fd1`. Читання через `fd2` функцією `read(fd2, buf, 1)` також повертає перший байт (символ 'A'), оскільки курсор fd2 не рухався після відкриття файлу. Читання за допомогою `fd1` вдруге повертає другий байт (символ 'B'), оскільки курсор `fd1` перемістився після першого читання.
4. **Закриття дескрипторів**. Після завершення операцій обидва дескриптори (`fd1` та `fd2`) закриваються функцією `close()`.
5. **Неочевидна поведінка**. Основна ідея полягає в тому, що кожен файловий дескриптор має власний незалежний курсор читання/запису.
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 171253](https://github.com/user-attachments/assets/281d86ec-9096-4e8d-8c9b-8e29b24939be)

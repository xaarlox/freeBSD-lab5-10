# freeBSD_lab9
## Завдання №1
Напишіть програму, яка читає файл /etc/passwd за допомогою команди getent passwd, щоб дізнатись, які облікові записи визначені на вашому комп’ютері. Програма повинна визначити, чи є серед них звичайні користувачі (ідентифікатори UID повинні бути більші за 500 або 1000, залежно від вашого дистрибутива), окрім вас.
## Реалізація завдання
Було написано програму, яка перевіряє облікові записи користувачів у системі через команду `getent passwd`, і визначає серед них звичайних користувачів з UID, більшим за заданий поріг, окрім поточного користувача.
+ **Виклик команди `getent passwd`**. Використовується функція `popen()` для отримання результатів команди, яка повертає список всіх облікових записів із `/etc/passwd`.
+ **Отримання UID поточного користувача**. `getuid()` визначає UID процесу, щоб порівнювати з іншими записами.
+ **Обробка результатів команди**. `fgets()` читає строки виводу `getent passwd`. Функція `strtok()` розбиває кожен рядок за роздільником `:`, витягуючи ім'я користувача і UID.
+ **Перевірка UID та вивід інформації**. UID порівнюється з порогом `UID_THRESHOLD` (1000 або 500). Користувачі з UID більше за поріг і не рівні UID поточного процесу відображаються як "звичайні користувачі".
+ **Вивід результатів**. Якщо знайдено хоча б одного користувача, виводиться його ім'я та UID. Якщо таких немає, програма повідомляє про їх відсутність.

## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 192237](https://github.com/user-attachments/assets/3b69c400-899f-4fbb-8ed4-ac4ae7fe4d78)

## Завдання №2
Напишіть програму, яка виконує команду cat /etc/shadow від імені адміністратора, хоча запускається від звичайного користувача. (Ваша програма повинна робити необхідне, виходячи з того, що конфігурація системи дозволяє отримувати адміністративний доступ за допомогою відповідної команди.)
## Реалізація завдання
Спочатку було використано `printf()` для інформування користувача про виконання команди. Після чого використано `execlp()` для виконання команди `sudo cat /etc/master.passwd`. Ця функція запускає новий процес, заміняючи поточний і виконує команду. Якщо команда `execlp()` не виконується успішно, виводиться повідомлення про помилку через `perror()`.
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 193126](https://github.com/user-attachments/assets/b307d86a-a76b-4b98-95ea-c4e7762b6e37)

## Завдання №3
Напишіть програму, яка від імені root копіює файл, який вона перед цим створила від імені звичайного користувача. Потім вона повинна помістити копію у домашній каталог звичайного користувача. Далі, використовуючи звичайний обліковий запис, програма намагається змінити файл і зберегти зміни. Що відбудеться? Після цього програма намагається видалити цей файл за допомогою команди rm. Що відбудеться?
## Реалізація завдання
Було написано програму, яка створює файл `/tmp/user_file.txt` як звичайний користувач із початковим вмістом "Initial content". Права доступу до файлу встановлюються на `0644` (читання для всіх, запис тільки для власника). Далі файл копіюється до домашнього каталогу звичайного користувача `/home/guest/copied_file.txt`. Після копіювання права власності змінюються на `root:wheel`, а права доступу встановлюються на `600` (повний доступ тільки для root). При спробі відкриття файлу для запису звичайним користувачем (з опцією `O_WRONLY`) виникає помилка доступу через недостатні права (оскільки файл належить root і недоступний для модифікації іншими користувачами). При спробі видалення файлу звичайним користувачем виникає помилка доступу. Це відбувається тому, що файл належить root, а права доступу не дозволяють звичайному користувачеві виконувати операції видалення (але оскільки було запущено ОС під `root`, то зазначені вище команди були виконані успішно).
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 194934](https://github.com/user-attachments/assets/ea220abe-e722-4e7e-9f6e-6cce50e2b232)

## Завдання №4
Напишіть програму, яка по черзі виконує команди whoami та id, щоб перевірити стан облікового запису користувача, від імені якого вона запущена. Є ймовірність, що команда id виведе список різних груп, до яких ви належите. Програма повинна це продемонструвати.
## Реалізація завдання
Було написано програму, яка запускає команду `whoami`, яка виводить ім'я поточного користувача системи. Це допомагає визначити обліковий запис, від імені якого виконуються операції. Якщо команда не виконується, відображається повідомлення про помилку через `perror`. Далі програма виконує команду `id`, яка виводить UID (ідентифікатор користувача), GID (ідентифікатор групи) і список груп, до яких належить користувач. Якщо є кілька груп, результат команди демонструє належність до них. Результати виконання кожної команди відображаються у консолі, що дозволяє побачити стан облікового запису користувача та його групи.
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 195406](https://github.com/user-attachments/assets/43c3c1cf-9333-40bd-9e43-3f1411e6bb00)

## Завдання №5
Напишіть програму, яка створює тимчасовий файл від імені звичайного користувача. Потім від імені суперкористувача використовує команди chown і chmod, щоб змінити тип володіння та права доступу. Програма повинна визначити, в яких випадках вона може виконувати читання та запис файлу, використовуючи свій обліковий запис.
## Реалізація завдання
Було написано програму, яка створює тимчасовий файл `/tmp/temp_access_test.txt` зі стандартними правами доступу `0644` (читання для всіх, запис тільки для власника). Файл заповнюється початковим вмістом "Test content". За допомогою команд `sudo chown` та `sudo chmod` змінюється власник файлу (`root:wheel`) та встановлюються права доступу `600` (читання і запис доступні тільки для root). Функція `check_access()` перевіряє права на читання (`R_OK`) та запис (`W_OK`) для поточного користувача. Відповідні повідомлення виводяться в консоль. Програма намагається прочитати вміст файлу. Якщо доступ заборонений, відображається повідомлення про помилку. Аналогічно здійснюється спроба запису до файлу, з повідомленням про успіх чи невдачу.
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 202106](https://github.com/user-attachments/assets/22e5ee2c-8798-45bc-9b4a-e3dea852cda7)

## Завдання №6
Напишіть програму, яка виконує команду ls -l, щоб переглянути власника і права доступу до файлів у своєму домашньому каталозі, в /usr/bin та в /etc. Продемонструйте, як ваша програма намагається обійти різні власники та права доступу користувачів, а також здійснює спроби читання, запису та виконання цих файлів.
## Реалізація завдання
Було написано програму, яка виконує команду `ls -l` для домашнього каталогу (`$HOME`), `/usr/bin`, і `/etc`, щоб отримати список файлів, їхніх власників і права доступу. Команда `system()` використовується для виконання цієї операції. У кожному каталозі програма проходить по списку файлів за допомогою `readdir()` та перевіряє доступність кожного файлу для читання (`R_OK`), запису (`W_OK`) і виконання (`X_OK`) за допомогою функції `access()`. Відповідні повідомлення виводяться в консоль, залежно від результату перевірки. Якщо файл у каталозі `/usr/bin` є виконуваним (`X_OK`), виводиться повідомлення про спробу виконання (реальне виконання не здійснюється, щоб програма не завершилася під час виконання). Програма демонструє, які файли доступні для читання, запису та виконання залежно від їхніх власників і встановлених прав доступу.
## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 205801](https://github.com/user-attachments/assets/4cad6992-f571-47ad-8ff8-c6e6faea39a1)

## Завдання №20
Спробуйте виконати команду як інший користувач, не змінюючи UID.
## Реалізація завдання
Було написано програму, яка демонструє імітацію виконання команди як інший користувач, не змінюючи реальний UID процесу. **Примітка:** даний підхід не змінює UID або права доступу процесу, а лише імітує зміну користувача через змінні оточення. Використання `execlp()` дозволяє виконувати команду в новому процесі, зберігаючи змінене оточення.
+ **Ініціалізація та виведення початкових даних**. `getuid()` показує реальний UID процесу, `getenv()` отримує значення змінних оточення (`USER`, `HOME`) для поточного користувача.
+ **Зміна змінних оточення**. Використовується `setenv()` для встановлення нових значень змінних оточення (`USER`, `HOME`, `SHELL`), щоб створити ілюзію виконання команди від іншого користувача. Ці зміни впливають лише на оточення процесу, не змінюючи UID.
+ **Імітація виконання команди**. `execlp()` запускає новий процес (в даному випадку оболонку `sh`) з використанням змінного оточення. Передається команда `echo Hello from $USER, home $HOME`, яка використовує змінені змінні оточення.
+ **Обробка помилок**. У разі невдачі `execlp()` викликається `perror()`, що виводить повідомлення про помилку.

## Компіляція та виконання завдання
![Знімок екрана 2025-04-30 172550](https://github.com/user-attachments/assets/97fe1885-7501-497b-bc7e-2a38984c2470)
